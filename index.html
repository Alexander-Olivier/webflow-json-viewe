<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Webflow JSON Viewer & Health Score A1</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f0f0f;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 24px;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    h1 { font-size: 28px; margin-bottom: 8px; color: #fff; }
    .subtitle { color: #888; margin-bottom: 24px; }
    .paste-zone {
      border: 2px dashed #333;
      border-radius: 12px;
      padding: 60px;
      text-align: center;
      transition: all 0.2s;
      cursor: pointer;
    }
    .paste-zone:hover { border-color: #4a9eff; background: rgba(74, 158, 255, 0.05); }
    .paste-zone .icon { font-size: 64px; margin-bottom: 16px; }
    .paste-zone h2 { font-size: 20px; color: #888; margin-bottom: 8px; }
    .paste-zone p { font-size: 14px; color: #555; }
    .error {
      margin-top: 16px;
      padding: 12px 16px;
      background: rgba(255, 80, 80, 0.1);
      border-radius: 8px;
      color: #ff6b6b;
    }
    .health-section {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      border: 1px solid #2a2a4a;
    }
    .health-header {
      display: flex;
      align-items: center;
      gap: 24px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    .health-score-circle {
      position: relative;
      width: 120px;
      height: 120px;
      flex-shrink: 0;
    }
    .health-score-circle svg { transform: rotate(-90deg); }
    .health-score-circle .bg { fill: none; stroke: #2a2a4a; stroke-width: 8; }
    .health-score-circle .progress {
      fill: none;
      stroke-width: 8;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.5s ease;
    }
    .health-score-circle .score-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }
    .health-score-circle .score-value { font-size: 32px; font-weight: 700; }
    .health-score-circle .score-label { font-size: 11px; color: #888; text-transform: uppercase; }
    .health-info { flex: 1; min-width: 250px; }
    .health-info h2 { font-size: 24px; margin-bottom: 8px; }
    .health-info .grade {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 6px;
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 12px;
    }
    .health-info .summary { color: #aaa; font-size: 14px; line-height: 1.5; }
    .health-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }
    .metric-card {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .metric-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .metric-title { font-size: 13px; color: #888; }
    .metric-score {
      font-size: 14px;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .metric-score.good { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .metric-score.warning { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    .metric-score.bad { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .metric-bar {
      height: 6px;
      background: #2a2a4a;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 12px;
    }
    .metric-bar-fill { height: 100%; border-radius: 3px; transition: width 0.5s ease; }
    .metric-details { font-size: 12px; color: #666; line-height: 1.6; }
    .metric-details ul { list-style: none; margin-top: 8px; }
    .metric-details li { padding: 4px 0; display: flex; align-items: center; gap: 8px; }
    .metric-details li::before {
      content: "";
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #555;
      flex-shrink: 0;
    }
    .metric-details li.issue::before { background: #ef4444; }
    .metric-details li.good::before { background: #22c55e; }
    .metric-details li.warning::before { background: #fbbf24; }
    .issues-section {
      margin-top: 24px;
      padding-top: 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    .issues-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .issues-header h3 { font-size: 16px; color: #fff; }
    .issues-toggle {
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: none;
      border-radius: 6px;
      color: #888;
      font-size: 12px;
      cursor: pointer;
    }
    .issues-toggle:hover { background: rgba(255, 255, 255, 0.1); color: #e0e0e0; }
    .issues-list { display: grid; gap: 8px; max-height: 300px; overflow-y: auto; }
    .issue-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      font-size: 13px;
    }
    .issue-icon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }
    .issue-icon.critical { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .issue-icon.warning { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    .issue-icon.info { background: rgba(74, 158, 255, 0.2); color: #4a9eff; }
    .issue-content { flex: 1; min-width: 0; }
    .issue-title { color: #e0e0e0; margin-bottom: 2px; word-break: break-word; }
    .issue-desc { color: #666; font-size: 12px; }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }
    .stat-card { background: #1a1a1a; border-radius: 12px; padding: 20px; }
    .stat-card .value { font-size: 32px; font-weight: 700; }
    .stat-card .label { font-size: 13px; color: #666; margin-top: 4px; }
    .stat-card.blue .value { color: #4a9eff; }
    .stat-card.cyan .value { color: #00d4aa; }
    .stat-card.purple .value { color: #a78bfa; }
    .stat-card.yellow .value { color: #fbbf24; }
    .element-types { background: #1a1a1a; border-radius: 12px; padding: 20px; margin-bottom: 24px; }
    .element-types h3 { font-size: 13px; color: #666; margin-bottom: 12px; }
    .type-tags { display: flex; flex-wrap: wrap; gap: 8px; }
    .type-tag { background: #252525; padding: 6px 12px; border-radius: 6px; font-size: 13px; }
    .type-tag .name { color: #a78bfa; }
    .type-tag .count { color: #666; margin-left: 4px; }
    .tabs { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
    .tab {
      padding: 10px 20px;
      background: #1a1a1a;
      border: none;
      border-radius: 8px;
      color: #888;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .tab:hover { background: #252525; color: #e0e0e0; }
    .tab.active { background: #4a9eff; color: #fff; }
    .toolbar { display: flex; gap: 8px; margin-left: auto; }
    .btn {
      padding: 10px 16px;
      background: #252525;
      border: none;
      border-radius: 8px;
      color: #888;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn:hover { background: #333; color: #e0e0e0; }
    .btn.danger { background: #4a1515; color: #ff6b6b; }
    .btn.danger:hover { background: #5a2020; }
    .search-input {
      width: 100%;
      padding: 12px 16px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      color: #e0e0e0;
      font-size: 14px;
      margin-bottom: 16px;
      outline: none;
    }
    .search-input:focus { border-color: #4a9eff; }
    .search-input::placeholder { color: #555; }
    .content-panel {
      background: #1a1a1a;
      border-radius: 12px;
      padding: 20px;
      max-height: 600px;
      overflow: auto;
    }
    .tree-node { padding: 4px 0; }
    .tree-node-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .tree-node-header:hover { background: #252525; }
    .tree-toggle { width: 16px; color: #555; font-size: 10px; flex-shrink: 0; }
    .tree-tag { color: #4a9eff; }
    .tree-type { color: #a78bfa; font-size: 12px; }
    .tree-name { color: #666; font-size: 12px; }
    .tree-classes { color: #00d4aa; font-size: 11px; }
    .tree-children { margin-left: 20px; padding-left: 12px; border-left: 1px solid #252525; }
    .style-item { padding: 16px 0; border-bottom: 1px solid #252525; }
    .style-item:last-child { border-bottom: none; }
    .style-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 4px;
      border-radius: 6px;
      flex-wrap: wrap;
    }
    .style-header:hover { background: #252525; }
    .style-name {
      color: #00d4aa;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 14px;
      font-weight: 600;
      word-break: break-all;
    }
    .style-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
      flex-shrink: 0;
    }
    .style-badge.framework { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .style-badge.utility { background: rgba(74, 158, 255, 0.2); color: #4a9eff; }
    .style-badge.random { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .style-variants { font-size: 11px; color: #a78bfa; }
    .style-details { margin-top: 12px; padding-left: 24px; }
    .style-id { font-size: 11px; color: #555; margin-bottom: 8px; word-break: break-all; }
    .style-css {
      background: #0f0f0f;
      padding: 12px;
      border-radius: 8px;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 12px;
      color: #00d4aa;
      white-space: pre-wrap;
      line-height: 1.6;
      word-break: break-word;
    }
    .variant-section { margin-top: 12px; }
    .variant-label { font-size: 11px; color: #a78bfa; margin-bottom: 6px; }
    .variant-name {
      color: #fbbf24;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 12px;
    }
    .raw-json {
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-all;
      color: #888;
      line-height: 1.5;
    }
    .copy-script { background: #1a1a1a; border-radius: 12px; padding: 20px; margin-top: 24px; }
    .copy-script h3 { font-size: 16px; margin-bottom: 12px; }
    .copy-script p { font-size: 13px; color: #888; margin-bottom: 12px; }
    .script-code {
      background: #0f0f0f;
      padding: 16px;
      border-radius: 8px;
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 12px;
      color: #00d4aa;
      overflow-x: auto;
      position: relative;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 6px 12px;
      background: #333;
      border: none;
      border-radius: 6px;
      color: #888;
      font-size: 12px;
      cursor: pointer;
    }
    .copy-btn:hover { background: #444; color: #e0e0e0; }
    .hidden { display: none; }
    .highlight { background: rgba(251, 191, 36, 0.2); border-radius: 4px; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #444; }
    .framework-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 8px;
      font-size: 13px;
      color: #22c55e;
      margin-right: 8px;
      margin-bottom: 8px;
    }
    .framework-badge.none {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }
    .detected-frameworks { margin-bottom: 16px; }
    @media (max-width: 600px) {
      body { padding: 12px; }
      .health-header { flex-direction: column; align-items: flex-start; }
      .tabs { flex-direction: column; }
      .toolbar { margin-left: 0; width: 100%; justify-content: flex-end; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Webflow JSON Viewer & Health Score</h1>
    <p class="subtitle">Copy an element from Webflow Designer, then paste here (Cmd+V / Ctrl+V)</p>

    <div id="pasteZone" class="paste-zone">
      <div class="icon">üìã</div>
      <h2>Paste Webflow JSON here</h2>
      <p>Use the console script below to copy from Webflow first</p>
      <div id="errorMsg" class="error hidden"></div>
    </div>

    <div id="mainContent" class="hidden">
      <div class="health-section" id="healthSection"></div>

      <div class="stats-grid">
        <div class="stat-card blue">
          <div class="value" id="statElements">0</div>
          <div class="label">Elements</div>
        </div>
        <div class="stat-card cyan">
          <div class="value" id="statClasses">0</div>
          <div class="label">Classes</div>
        </div>
        <div class="stat-card purple">
          <div class="value" id="statInteractions">0</div>
          <div class="label">Interactions</div>
        </div>
        <div class="stat-card yellow">
          <div class="value" id="statSymbols">0</div>
          <div class="label">Unlinked Symbols</div>
        </div>
      </div>

      <div class="element-types">
        <h3>Element Types</h3>
        <div class="type-tags" id="typeTags"></div>
      </div>

      <div class="tabs">
        <button class="tab active" data-tab="tree">Element Tree</button>
        <button class="tab" data-tab="styles">Styles <span id="stylesCount"></span></button>
        <button class="tab" data-tab="raw">Raw JSON</button>
        <div class="toolbar">
          <button class="btn" id="expandAllBtn">Expand All</button>
          <button class="btn" id="collapseAllBtn">Collapse All</button>
          <button class="btn danger" id="clearBtn">Clear</button>
        </div>
      </div>

      <input type="text" class="search-input" id="searchInput" placeholder="Search elements or classes...">

      <div class="content-panel">
        <div id="treeContent"></div>
        <div id="stylesContent" class="hidden"></div>
        <div id="rawContent" class="hidden"></div>
      </div>
    </div>

    <div class="copy-script">
      <h3>üìù How to copy from Webflow</h3>
      <p>Paste this script in the browser console while in Webflow Designer, then copy any element:</p>
      <div class="script-code">
        <button class="copy-btn" id="copyScriptBtn">Copy</button>
        <code>document.addEventListener('copy', ({ clipboardData }) => {
  const webflowData = clipboardData.getData('application/json');
  const type = 'text/plain';
  const blob = new Blob([webflowData], { type });
  const data = [new ClipboardItem({ [type]: blob })];
  navigator.clipboard.write(data);
  console.log('Copied! Paste into the viewer.');
});</code>
      </div>
    </div>
  </div>

  <script>
    let jsonData = null;
    let expandedNodes = new Set();
    let activeTab = 'tree';
    let searchTerm = '';
    let healthAnalysis = null;
    let showAllIssues = false;

    // STRICT Framework patterns - must be very specific
    const FRAMEWORK_PATTERNS = {
      'MAST': {
        patterns: ['page-wrapper', 'page-main', 'slot', 'u-d-flex', 'u-mb-', 'u-mt-', 'u-pt-', 'u-pb-', 'cc-', 'row-gap-', 'col-shrink', 'col-md-', 'col-lg-'],
        required: ['page-wrapper', 'slot'], // Must have these
        minMatches: 5,
        description: 'No-Code Supply Co. MAST Framework'
      },
      'Client-First': {
        patterns: ['page_', 'section_', 'padding-global', 'padding-section-', 'container-', 'margin-', 'text-size-', 'heading-style-', 'button_', 'spacer-', 'max-width-', 'fs-styleguide'],
        required: ['page_', 'padding-global'],
        minMatches: 5,
        description: 'Finsweet Client-First'
      },
      'Relume': {
        patterns: ['navbar_component', 'navbar_container', 'footer_component', 'section_', 'padding-vertical', 'padding-global', 'layout_component'],
        required: [],
        minMatches: 4,
        description: 'Relume Library'
      }
    };

    // Utility patterns (good)
    const UTILITY_PATTERNS = [
      /^u-[a-z]/, /^is-[a-z]/, /^has-[a-z]/, /^cc-[a-z]/, /^mod-[a-z]/, /^js-[a-z]/
    ];

    // EXPANDED Random/bad class patterns - Webflow defaults
    const RANDOM_PATTERNS = [
      // Exact Webflow defaults
      /^div-block$/i, /^div-block-\d+$/i,
      /^section$/i, /^section-\d+$/i,
      /^container$/i, /^container-\d+$/i,
      /^heading$/i, /^heading-\d+$/i,
      /^paragraph$/i, /^paragraph-\d+$/i,
      /^text-block$/i, /^text-block-\d+$/i,
      /^link-block$/i, /^link-block-\d+$/i,
      /^image$/i, /^image-\d+$/i,
      /^button$/i, /^button-\d+$/i,
      /^form-block$/i, /^form-block-\d+$/i,
      /^text-field$/i, /^text-field-\d+$/i,
      /^submit-button$/i, /^submit-button-\d+$/i,
      /^columns$/i, /^columns-\d+$/i,
      /^column$/i, /^column-\d+$/i,
      /^grid$/i, /^grid-\d+$/i,
      /^list$/i, /^list-\d+$/i,
      /^list-item$/i, /^list-item-\d+$/i,
      /^block$/i, /^block-\d+$/i,
      /^wrapper$/i, /^wrapper-\d+$/i,
      /^content$/i, /^content-\d+$/i,
      /^html-embed$/i, /^html-embed-\d+$/i,
      /^video$/i, /^video-\d+$/i,
      /^background-video$/i,
      /^lightbox-link$/i,
      /^slider$/i, /^slide$/i, /^mask$/i,
      /^tab-link$/i, /^tabs-content$/i, /^tabs-menu$/i,
      /^dropdown$/i, /^dropdown-toggle$/i, /^dropdown-list$/i,
      /^nav-link$/i, /^nav-menu$/i, /^navbar$/i,
      /^brand$/i, /^menu-button$/i,
      // Copy patterns
      /^.+-copy$/i, /^.+-copy-\d+$/i,
      /^copy-of-.+$/i,
      // Numbered patterns (lazy naming)
      /^[a-z]+-\d+$/i,
      /^_[a-z]+\d*$/i,
      // Generic bad names
      /^class$/i, /^class-\d+$/i,
      /^new-class$/i, /^new-class-\d+$/i,
      /^style$/i, /^style-\d+$/i,
      /^box$/i, /^box-\d+$/i,
      /^item$/i, /^item-\d+$/i,
      /^element$/i, /^element-\d+$/i,
      /^component$/i, /^component-\d+$/i,
      /^module$/i, /^module-\d+$/i,
      /^area$/i, /^area-\d+$/i,
      /^holder$/i, /^holder-\d+$/i,
      /^group$/i, /^group-\d+$/i,
      /^inner$/i, /^outer$/i,
      /^top$/i, /^bottom$/i, /^left$/i, /^right$/i,
      /^main$/i, /^sub$/i,
      /^big$/i, /^small$/i,
      /^new$/i, /^old$/i,
      /^test$/i, /^temp$/i, /^tmp$/i,
      // Single letters or very short
      /^[a-z]$/i, /^[a-z]{2}$/i
    ];

    // BEM pattern
    const BEM_PATTERN = /^[a-z][a-z0-9]*(-[a-z0-9]+)*(__[a-z0-9]+(-[a-z0-9]+)*)?(--[a-z0-9]+(-[a-z0-9]+)*)?$/i;

    const pasteZone = document.getElementById('pasteZone');
    const mainContent = document.getElementById('mainContent');
    const errorMsg = document.getElementById('errorMsg');
    const searchInput = document.getElementById('searchInput');
    const treeContent = document.getElementById('treeContent');
    const stylesContent = document.getElementById('stylesContent');
    const rawContent = document.getElementById('rawContent');
    const healthSection = document.getElementById('healthSection');

    document.addEventListener('paste', handlePaste);
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });
    document.getElementById('expandAllBtn').addEventListener('click', expandAll);
    document.getElementById('collapseAllBtn').addEventListener('click', collapseAll);
    document.getElementById('clearBtn').addEventListener('click', clearData);
    searchInput.addEventListener('input', (e) => {
      searchTerm = e.target.value.toLowerCase();
      render();
    });
    document.getElementById('copyScriptBtn').addEventListener('click', () => {
      const script = document.querySelector('.script-code code').textContent;
      navigator.clipboard.writeText(script);
      document.getElementById('copyScriptBtn').textContent = 'Copied!';
      setTimeout(() => document.getElementById('copyScriptBtn').textContent = 'Copy', 2000);
    });

    function handlePaste(e) {
      const text = e.clipboardData.getData('text/plain') || e.clipboardData.getData('application/json');
      if (!text) return;

      try {
        const parsed = JSON.parse(text);
        if (parsed.type === '@webflow/XscpData') {
          // Reset everything
          jsonData = parsed;
          expandedNodes = new Set(['root']);
          showAllIssues = false;
          searchTerm = '';
          searchInput.value = '';
          
          if (parsed.payload?.nodes) {
            const rootNodes = findRootNodes(parsed.payload.nodes);
            rootNodes.forEach(n => expandedNodes.add('node-' + n._id));
          }
          
          // Fresh analysis
          healthAnalysis = analyzeProjectHealth(parsed);
          showError('');
          render();
        } else {
          showError('Valid JSON but not Webflow format. Looking for type: @webflow/XscpData');
        }
      } catch (err) {
        showError('Invalid JSON: ' + err.message);
      }
    }

    function showError(msg) {
      errorMsg.textContent = msg;
      errorMsg.classList.toggle('hidden', !msg);
    }

    function findRootNodes(nodes) {
      const childIds = new Set();
      nodes.forEach(n => (n.children || []).forEach(id => childIds.add(id)));
      return nodes.filter(n => !childIds.has(n._id));
    }

    // ========== HEALTH ANALYSIS ==========

    function analyzeProjectHealth(data) {
      const styles = data.payload?.styles || [];
      const nodes = data.payload?.nodes || [];
      
      // Fresh analysis object
      const analysis = {
        score: 0,
        grade: 'F',
        summary: '',
        frameworks: [],
        metrics: {
          namingConvention: { score: 0, max: 30, details: [] },
          classReuse: { score: 0, max: 20, details: [] },
          comboClasses: { score: 0, max: 15, details: [] },
          cssVariables: { score: 0, max: 15, details: [] },
          structure: { score: 0, max: 20, details: [] }
        },
        issues: [],
        classBreakdown: { framework: [], utility: [], semantic: [], random: [], combo: [] }
      };

      // Run all analysis
      analysis.frameworks = detectFrameworks(styles);
      analyzeNaming(styles, analysis);
      analyzeReuse(styles, nodes, analysis);
      analyzeComboClasses(styles, analysis);
      analyzeVariables(styles, analysis);
      analyzeStructure(nodes, analysis);

      // Calculate score
      let totalScore = 0, maxScore = 0;
      Object.values(analysis.metrics).forEach(m => {
        totalScore += m.score;
        maxScore += m.max;
      });
      
      analysis.score = Math.round((totalScore / maxScore) * 100);
      analysis.grade = getGrade(analysis.score);
      analysis.summary = getSummary(analysis);

      // Debug
      console.log('Analysis:', analysis);
      console.log('Random classes:', analysis.classBreakdown.random);

      return analysis;
    }

    function detectFrameworks(styles) {
      const detected = [];
      const classNames = styles.map(s => (s.name || '').toLowerCase());

      Object.entries(FRAMEWORK_PATTERNS).forEach(([name, config]) => {
        let matchCount = 0;
        let matchedPatterns = [];
        let hasRequired = config.required.length === 0;
        
        // Check required patterns
        if (config.required.length > 0) {
          hasRequired = config.required.every(req => 
            classNames.some(cn => cn.includes(req.toLowerCase()))
          );
        }
        
        // Count pattern matches
        config.patterns.forEach(pattern => {
          const patternLower = pattern.toLowerCase();
          const matches = classNames.filter(cn => cn.startsWith(patternLower) || cn === patternLower);
          if (matches.length > 0) {
            matchCount += matches.length;
            matchedPatterns.push(pattern);
          }
        });
        
        if (hasRequired && matchCount >= config.minMatches) {
          detected.push({
            name,
            description: config.description,
            matchCount,
            matchedPatterns: matchedPatterns.slice(0, 5)
          });
        }
      });

      return detected.sort((a, b) => b.matchCount - a.matchCount);
    }

    function isRandomClassName(name) {
      if (!name) return false;
      return RANDOM_PATTERNS.some(pattern => pattern.test(name));
    }

    function isUtilityClassName(name) {
      if (!name) return false;
      return UTILITY_PATTERNS.some(pattern => pattern.test(name));
    }

    function isFrameworkClassName(name, frameworks) {
      if (!name) return false;
      const nameLower = name.toLowerCase();
      
      for (const fw of frameworks) {
        const config = FRAMEWORK_PATTERNS[fw.name];
        if (config) {
          for (const pattern of config.patterns) {
            if (nameLower.startsWith(pattern.toLowerCase())) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function analyzeNaming(styles, analysis) {
      let frameworkCount = 0;
      let utilityCount = 0;
      let semanticCount = 0;
      let randomCount = 0;

      styles.forEach(style => {
        const name = style.name || '';
        if (!name) return;
        
        // Check in order of priority
        if (isRandomClassName(name)) {
          randomCount++;
          analysis.classBreakdown.random.push(name);
        } else if (isFrameworkClassName(name, analysis.frameworks)) {
          frameworkCount++;
          analysis.classBreakdown.framework.push(name);
        } else if (isUtilityClassName(name)) {
          utilityCount++;
          analysis.classBreakdown.utility.push(name);
        } else {
          semanticCount++;
          analysis.classBreakdown.semantic.push(name);
        }
      });

      // Add issues for random classes
      const randomList = analysis.classBreakdown.random;
      randomList.slice(0, 8).forEach(name => {
        analysis.issues.push({
          type: 'warning',
          title: `Bad class name: .${name}`,
          desc: 'Rename with semantic meaning'
        });
      });
      if (randomList.length > 8) {
        analysis.issues.push({
          type: 'critical',
          title: `+${randomList.length - 8} more random class names`,
          desc: 'Major cleanup needed'
        });
      }

      const total = styles.length || 1;
      const randomRatio = randomCount / total;
      const frameworkRatio = frameworkCount / total;

      // STRICT scoring for naming
      let score = 30;
      
      // Heavy penalty for random classes
      if (randomRatio > 0.5) score -= 25;
      else if (randomRatio > 0.3) score -= 20;
      else if (randomRatio > 0.2) score -= 15;
      else if (randomRatio > 0.1) score -= 10;
      else if (randomRatio > 0.05) score -= 5;
      
      // Bonus for framework/utility usage
      if (frameworkCount > 10) score += 3;
      if (utilityCount > 5) score += 2;

      analysis.metrics.namingConvention.score = Math.max(0, Math.min(30, score));
      analysis.metrics.namingConvention.details = [
        { text: `${frameworkCount} framework classes`, type: frameworkCount > 0 ? 'good' : 'info' },
        { text: `${utilityCount} utility classes`, type: utilityCount > 0 ? 'good' : 'info' },
        { text: `${semanticCount} semantic classes`, type: 'info' },
        { text: `${randomCount} random/bad names (${Math.round(randomRatio*100)}%)`, type: randomCount > 3 ? 'issue' : randomCount > 0 ? 'warning' : 'good' }
      ];

      if (randomRatio > 0.3) {
        analysis.issues.unshift({
          type: 'critical',
          title: `${Math.round(randomRatio*100)}% of classes have poor names`,
          desc: 'This project needs significant class renaming for maintainability.'
        });
      }
    }

    function analyzeReuse(styles, nodes, analysis) {
      const classUsage = {};
      nodes.forEach(node => {
        (node.classes || []).forEach(classId => {
          classUsage[classId] = (classUsage[classId] || 0) + 1;
        });
      });

      const total = styles.length || 1;
      let reused = 0, single = 0, unused = 0;

      styles.forEach(style => {
        const usage = classUsage[style._id] || 0;
        if (usage > 1) reused++;
        else if (usage === 1) single++;
        else unused++;
      });

      const reuseRatio = reused / total;
      const singleRatio = single / total;

      let score = 20;
      if (reuseRatio < 0.1) score -= 10;
      else if (reuseRatio < 0.2) score -= 5;
      if (singleRatio > 0.7) score -= 8;
      else if (singleRatio > 0.5) score -= 4;
      if (unused > 5) score -= 3;

      analysis.metrics.classReuse.score = Math.max(0, Math.min(20, score));
      analysis.metrics.classReuse.details = [
        { text: `${reused} classes reused (${Math.round(reuseRatio*100)}%)`, type: reuseRatio > 0.2 ? 'good' : 'warning' },
        { text: `${single} single-use classes`, type: singleRatio > 0.6 ? 'warning' : 'info' },
        { text: `${unused} unused classes`, type: unused > 0 ? 'warning' : 'good' }
      ];

      if (reuseRatio < 0.15) {
        analysis.issues.push({
          type: 'warning',
          title: 'Low class reuse',
          desc: 'Most classes are only used once. Create reusable utilities.'
        });
      }
    }

    function analyzeComboClasses(styles, analysis) {
      const combos = styles.filter(s => s.comb === '&').length;
      const bases = styles.length - combos;
      const ratio = combos / (styles.length || 1);

      analysis.classBreakdown.combo = styles.filter(s => s.comb === '&').map(s => s.name);

      let score = 15;
      if (ratio < 0.05 && styles.length > 10) score -= 8;
      else if (ratio < 0.1) score -= 4;
      if (ratio > 0.6) score -= 5;

      analysis.metrics.comboClasses.score = Math.max(0, Math.min(15, score));
      analysis.metrics.comboClasses.details = [
        { text: `${combos} combo classes`, type: combos > 0 ? 'good' : 'warning' },
        { text: `${bases} base classes`, type: 'info' },
        { text: `${Math.round(ratio*100)}% combo ratio`, type: ratio >= 0.1 && ratio < 0.5 ? 'good' : 'warning' }
      ];

      if (ratio < 0.05 && styles.length > 15) {
        analysis.issues.push({
          type: 'info',
          title: 'No combo classes',
          desc: 'Use combo classes for variations (.btn.is-primary)'
        });
      }
    }

    function analyzeVariables(styles, analysis) {
      let varRefs = 0, hardColors = 0, hardSizes = 0;

      const varRegex = /var\s*\(\s*--[^)]+\)/gi;
      const colorRegex = /#[0-9a-fA-F]{3,8}(?![0-9a-fA-F])|rgba?\s*\([^)]+\)|hsla?\s*\([^)]+\)/gi;
      const sizeRegex = /:\s*\d+px/g;

      styles.forEach(style => {
        const css = style.styleLess || '';
        varRefs += (css.match(varRegex) || []).length;
        
        const cssNoVars = css.replace(varRegex, '');
        hardColors += (cssNoVars.match(colorRegex) || []).length;
        hardSizes += (cssNoVars.match(sizeRegex) || []).length;
      });

      let score = 15;
      if (varRefs === 0 && styles.length > 5) score -= 10;
      else if (varRefs < 5) score -= 5;
      if (hardColors > 20) score -= 5;
      else if (hardColors > 10) score -= 3;

      analysis.metrics.cssVariables.score = Math.max(0, Math.min(15, score));
      analysis.metrics.cssVariables.details = [
        { text: `${varRefs} variable references`, type: varRefs > 5 ? 'good' : varRefs > 0 ? 'info' : 'issue' },
        { text: `${hardColors} hardcoded colors`, type: hardColors > 15 ? 'issue' : hardColors > 5 ? 'warning' : 'good' },
        { text: `${hardSizes} hardcoded px values`, type: 'info' }
      ];

      if (varRefs === 0 && styles.length > 10) {
        analysis.issues.push({
          type: 'critical',
          title: 'No CSS variables',
          desc: 'Use Webflow variables for colors and spacing.'
        });
      }
    }

    function analyzeStructure(nodes, analysis) {
      let score = 20;
      const details = [];

      // Nesting depth
      const maxDepth = calcMaxDepth(nodes);
      if (maxDepth > 12) {
        score -= 8;
        details.push({ text: `Deep nesting: ${maxDepth} levels`, type: 'issue' });
        analysis.issues.push({ type: 'warning', title: `Nesting ${maxDepth} levels deep`, desc: 'Flatten your structure' });
      } else if (maxDepth > 8) {
        score -= 3;
        details.push({ text: `Nesting: ${maxDepth} levels`, type: 'warning' });
      } else {
        details.push({ text: `Nesting: ${maxDepth} levels`, type: 'good' });
      }

      // Div soup
      const divs = nodes.filter(n => n.tag === 'div' && n.type === 'Block').length;
      const divRatio = divs / (nodes.length || 1);
      if (divRatio > 0.85) {
        score -= 7;
        details.push({ text: `${Math.round(divRatio*100)}% divs (div soup!)`, type: 'issue' });
        analysis.issues.push({ type: 'warning', title: 'Div soup', desc: 'Use semantic HTML elements' });
      } else if (divRatio > 0.7) {
        score -= 3;
        details.push({ text: `${Math.round(divRatio*100)}% div elements`, type: 'warning' });
      } else {
        details.push({ text: `${Math.round(divRatio*100)}% div elements`, type: 'good' });
      }

      // Semantic elements
      const semantic = nodes.filter(n => ['section','article','nav','header','footer','main','aside'].includes(n.tag)).length;
      if (semantic > 3) {
        details.push({ text: `${semantic} semantic elements`, type: 'good' });
      } else if (semantic > 0) {
        details.push({ text: `${semantic} semantic elements`, type: 'info' });
      } else if (nodes.length > 10) {
        score -= 3;
        details.push({ text: 'No semantic HTML', type: 'warning' });
      }

      analysis.metrics.structure.score = Math.max(0, Math.min(20, score));
      analysis.metrics.structure.details = details;
    }

    function calcMaxDepth(nodes) {
      if (!nodes?.length) return 0;
      const map = {};
      nodes.forEach(n => map[n._id] = n);
      const roots = findRootNodes(nodes);
      
      function depth(node, d = 1) {
        if (!node?.children?.length) return d;
        return Math.max(...node.children.map(id => map[id] ? depth(map[id], d + 1) : d));
      }
      
      return roots.length ? Math.max(...roots.map(n => depth(n))) : 0;
    }

    function getGrade(score) {
      if (score >= 90) return 'A+';
      if (score >= 85) return 'A';
      if (score >= 80) return 'B+';
      if (score >= 70) return 'B';
      if (score >= 60) return 'C';
      if (score >= 50) return 'D';
      return 'F';
    }

    function getSummary(analysis) {
      const { score, frameworks } = analysis;
      const fw = frameworks.length ? ` Detected: ${frameworks[0].name}.` : ' No framework detected.';
      
      if (score >= 85) return `Excellent! Well-structured and scalable.${fw}`;
      if (score >= 70) return `Good foundation with room for improvement.${fw}`;
      if (score >= 55) return `Needs work on naming and organization.${fw}`;
      if (score >= 40) return `Significant issues. Consider adopting a framework.${fw}`;
      return `Major restructuring needed. This will be hard to maintain.${fw}`;
    }

    function getScoreColor(s) {
      if (s >= 75) return '#22c55e';
      if (s >= 50) return '#fbbf24';
      return '#ef4444';
    }

    // ========== RENDER ==========

    function render() {
      if (!jsonData) {
        pasteZone.classList.remove('hidden');
        mainContent.classList.add('hidden');
        return;
      }

      pasteZone.classList.add('hidden');
      mainContent.classList.remove('hidden');

      renderHealthScore();
      renderStats();
      renderElementTypes();
      renderTree();
      renderStyles();
      renderRaw();
    }

    function renderHealthScore() {
      if (!healthAnalysis) return;

      const { score, grade, summary, frameworks, metrics, issues } = healthAnalysis;
      const color = getScoreColor(score);
      const circ = 2 * Math.PI * 52;
      const offset = circ - (score / 100) * circ;

      healthSection.innerHTML = `
        <div class="health-header">
          <div class="health-score-circle">
            <svg width="120" height="120">
              <circle class="bg" cx="60" cy="60" r="52"></circle>
              <circle class="progress" cx="60" cy="60" r="52" stroke="${color}" stroke-dasharray="${circ}" stroke-dashoffset="${offset}"></circle>
            </svg>
            <div class="score-text">
              <div class="score-value" style="color:${color}">${score}</div>
              <div class="score-label">Health</div>
            </div>
          </div>
          <div class="health-info">
            <h2>Project Health Score</h2>
            <span class="grade" style="background:${color}20;color:${color}">Grade: ${grade}</span>
            <p class="summary">${summary}</p>
          </div>
        </div>
        <div class="detected-frameworks">
          ${frameworks.length ? frameworks.map(f => `<span class="framework-badge">‚úì ${f.name} <span style="opacity:0.7;font-size:11px">(${f.matchCount} matches)</span></span>`).join('') : '<span class="framework-badge none">‚ö† No framework detected</span>'}
        </div>
        <div class="health-metrics">
          ${Object.entries(metrics).map(([key, m]) => {
            const pct = Math.round((m.score / m.max) * 100);
            const col = pct >= 70 ? '#22c55e' : pct >= 40 ? '#fbbf24' : '#ef4444';
            const titles = {
              namingConvention: 'üìù Naming',
              classReuse: '‚ôªÔ∏è Reuse',
              comboClasses: 'üîó Combos',
              cssVariables: 'üé® Variables',
              structure: 'üèóÔ∏è Structure'
            };
            return `
              <div class="metric-card">
                <div class="metric-header">
                  <span class="metric-title">${titles[key]}</span>
                  <span class="metric-score ${pct >= 70 ? 'good' : pct >= 40 ? 'warning' : 'bad'}">${m.score}/${m.max}</span>
                </div>
                <div class="metric-bar"><div class="metric-bar-fill" style="width:${pct}%;background:${col}"></div></div>
                <div class="metric-details"><ul>${m.details.map(d => `<li class="${d.type}">${d.text}</li>`).join('')}</ul></div>
              </div>
            `;
          }).join('')}
        </div>
        ${issues.length ? `
          <div class="issues-section">
            <div class="issues-header">
              <h3>‚ö†Ô∏è Issues (${issues.length})</h3>
              ${issues.length > 5 ? `<button class="issues-toggle" onclick="toggleIssues()">${showAllIssues ? 'Less' : 'All'}</button>` : ''}
            </div>
            <div class="issues-list">
              ${(showAllIssues ? issues : issues.slice(0, 5)).map(i => `
                <div class="issue-item">
                  <div class="issue-icon ${i.type}">${i.type === 'critical' ? '!' : i.type === 'warning' ? '‚ö†' : 'i'}</div>
                  <div class="issue-content">
                    <div class="issue-title">${esc(i.title)}</div>
                    <div class="issue-desc">${esc(i.desc)}</div>
                  </div>
                </div>
              `).join('')}
              ${!showAllIssues && issues.length > 5 ? `<div class="issue-item" style="opacity:0.6;cursor:pointer" onclick="toggleIssues()"><div class="issue-content"><div class="issue-title">+ ${issues.length - 5} more</div></div></div>` : ''}
            </div>
          </div>
        ` : '<div style="margin-top:16px;color:#22c55e">‚úì No major issues</div>'}
      `;
    }

    window.toggleIssues = () => { showAllIssues = !showAllIssues; renderHealthScore(); };

    function renderStats() {
      const { nodes, styles, ix2 } = jsonData.payload || {};
      document.getElementById('statElements').textContent = nodes?.length || 0;
      document.getElementById('statClasses').textContent = styles?.length || 0;
      document.getElementById('statInteractions').textContent = ix2?.interactions?.length || 0;
      document.getElementById('statSymbols').textContent = jsonData.meta?.unlinkedSymbolCount || 0;
      document.getElementById('stylesCount').textContent = `(${styles?.length || 0})`;
    }

    function renderElementTypes() {
      const nodes = jsonData.payload?.nodes || [];
      const types = {};
      nodes.forEach(n => types[n.type] = (types[n.type] || 0) + 1);
      document.getElementById('typeTags').innerHTML = Object.entries(types)
        .sort((a, b) => b[1] - a[1])
        .map(([t, c]) => `<span class="type-tag"><span class="name">${t}</span><span class="count">√ó${c}</span></span>`)
        .join('');
    }

    function getStyleName(id) {
      const s = (jsonData.payload?.styles || []).find(x => x._id === id);
      return s?.name || id.slice(0, 8);
    }

    function getClassCategory(name) {
      if (!healthAnalysis) return '';
      const b = healthAnalysis.classBreakdown;
      if (b.random.includes(name)) return 'random';
      if (b.framework.includes(name)) return 'framework';
      if (b.utility.includes(name)) return 'utility';
      if (b.combo.includes(name)) return 'combo';
      return '';
    }

    function renderTree() {
      const nodes = jsonData.payload?.nodes || [];
      const map = {};
      nodes.forEach(n => map[n._id] = n);
      const roots = findRootNodes(nodes);

      function rn(node) {
        const id = 'node-' + node._id;
        const exp = expandedNodes.has(id);
        const hasKids = node.children?.length > 0;
        const name = node.meta?.displayName || node.data?.displayName || '';
        const classes = (node.classes || []).map(c => getStyleName(c));
        const match = searchTerm && (
          node.type?.toLowerCase().includes(searchTerm) ||
          node.tag?.toLowerCase().includes(searchTerm) ||
          name?.toLowerCase().includes(searchTerm) ||
          classes.some(c => c.toLowerCase().includes(searchTerm))
        );

        let h = `<div class="tree-node ${match ? 'highlight' : ''}">
          <div class="tree-node-header" data-node-id="${id}">
            <span class="tree-toggle">${hasKids ? (exp ? '‚ñº' : '‚ñ∂') : ''}</span>
            <span class="tree-tag">&lt;${node.tag || 'div'}&gt;</span>
            <span class="tree-type">${node.type}</span>
            ${name ? `<span class="tree-name">"${esc(name)}"</span>` : ''}
            ${classes.length ? `<span class="tree-classes">.${classes.slice(0, 3).join(' .')}${classes.length > 3 ? ' +' + (classes.length - 3) : ''}</span>` : ''}
          </div>`;
        if (exp && hasKids) {
          h += '<div class="tree-children">';
          node.children.forEach(cid => { if (map[cid]) h += rn(map[cid]); });
          h += '</div>';
        }
        return h + '</div>';
      }

      treeContent.innerHTML = roots.map(n => rn(n)).join('');
      treeContent.querySelectorAll('.tree-node-header').forEach(el => {
        el.addEventListener('click', () => {
          const id = el.dataset.nodeId;
          expandedNodes.has(id) ? expandedNodes.delete(id) : expandedNodes.add(id);
          renderTree();
        });
      });
    }

    function renderStyles() {
      const styles = jsonData.payload?.styles || [];
      const filtered = searchTerm ? styles.filter(s => s.name?.toLowerCase().includes(searchTerm)) : styles;

      stylesContent.innerHTML = filtered.map(s => {
        const id = 'style-' + s._id;
        const exp = expandedNodes.has(id);
        const vars = s.variants ? Object.keys(s.variants).length : 0;
        const cat = getClassCategory(s.name);

        let h = `<div class="style-item">
          <div class="style-header" data-style-id="${id}">
            <span class="tree-toggle">${exp ? '‚ñº' : '‚ñ∂'}</span>
            <span class="style-name">.${esc(s.name || '(unnamed)')}</span>
            ${s.comb === '&' ? '<span class="style-badge">combo</span>' : ''}
            ${cat === 'framework' ? '<span class="style-badge framework">framework</span>' : ''}
            ${cat === 'utility' ? '<span class="style-badge utility">utility</span>' : ''}
            ${cat === 'random' ? '<span class="style-badge random">random</span>' : ''}
            ${vars > 0 ? `<span class="style-variants">${vars} variants</span>` : ''}
          </div>`;

        if (exp) {
          const css = s.styleLess ? s.styleLess.split(';').filter(Boolean).map(x => x.trim()).join(';\n') : '';
          h += `<div class="style-details">
            <div class="style-id">ID: ${s._id}</div>
            ${css ? `<div class="style-css">${esc(css)}</div>` : ''}`;
          if (vars > 0) {
            h += '<div class="variant-section"><div class="variant-label">Variants:</div>';
            Object.entries(s.variants).forEach(([vn, vd]) => {
              const vc = vd.styleLess ? vd.styleLess.split(';').filter(Boolean).map(x => x.trim()).join(';\n') : '';
              h += `<div style="margin:8px 0"><span class="variant-name">${esc(vn)}:</span>${vc ? `<div class="style-css">${esc(vc)}</div>` : ''}</div>`;
            });
            h += '</div>';
          }
          h += '</div>';
        }
        return h + '</div>';
      }).join('');

      stylesContent.querySelectorAll('.style-header').forEach(el => {
        el.addEventListener('click', () => {
          const id = el.dataset.styleId;
          expandedNodes.has(id) ? expandedNodes.delete(id) : expandedNodes.add(id);
          renderStyles();
        });
      });
    }

    function renderRaw() {
      rawContent.innerHTML = `<pre class="raw-json">${esc(JSON.stringify(jsonData, null, 2))}</pre>`;
    }

    function esc(t) {
      if (!t) return '';
      const d = document.createElement('div');
      d.textContent = t;
      return d.innerHTML;
    }

    function switchTab(tab) {
      activeTab = tab;
      document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
      treeContent.classList.toggle('hidden', tab !== 'tree');
      stylesContent.classList.toggle('hidden', tab !== 'styles');
      rawContent.classList.toggle('hidden', tab !== 'raw');
    }

    function expandAll() {
      (jsonData.payload?.nodes || []).forEach(n => expandedNodes.add('node-' + n._id));
      (jsonData.payload?.styles || []).forEach(s => expandedNodes.add('style-' + s._id));
      render();
    }

    function collapseAll() {
      expandedNodes = new Set(['root']);
      render();
    }

    function clearData() {
      jsonData = null;
      healthAnalysis = null;
      expandedNodes = new Set();
      searchTerm = '';
      showAllIssues = false;
      searchInput.value = '';
      render();
    }
  </script>
</body>
</html>
